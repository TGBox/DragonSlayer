package newVersion.meta;

import java.util.concurrent.ThreadLocalRandom;
import newVersion.classes.Character;
import newVersion.classes.Enemy;
import newVersion.classes.Field;
import newVersion.classes.Map;
import newVersion.newCreators.MapCreator;
import newVersion.oldCreators.WeaponCreator;

/**
 * Created by
 * Daniel Roesch
 * as "Nils Darmstrong".
 * -----------------
 * For "DragonSlayerDANI",
 * on 10.05.2017, 19:38.
 */
public class Game{

  private static final int START_MAP_ID = 1;
  private static final boolean START_GAME_WON = false;
  private static final boolean START_IN_FIGHT = false;
  private static final int MIN_FIELD_WIDTH = 3;
  private static final int MAX_FIELD_WIDTH = 7;
  private static final int MIN_FIELD_HEIGHT = 4;
  private static final int MAX_FIELD_HEIGHT = 7;

  private Character player;
  private Map map;
  private Difficulty difficulty;
  private int currentMapID;
  private boolean gameWon;
  private boolean inFight;

  /**
   * constructor method to create a new game object.
   * @param playerName String player name.
   * @param gender Gender of the player.
   * @param diff Difficulty.
   */
  public Game(String playerName, Gender gender, Difficulty diff){
    this.player = new Character(playerName, gender, diff, WeaponCreator.createStartingWeapon());
    this.difficulty = diff;
    this.currentMapID = START_MAP_ID;
    this.gameWon = START_GAME_WON;
    this.inFight = START_IN_FIGHT;
    this.map = MapCreator.createNewMap(randInt(MIN_FIELD_WIDTH, MAX_FIELD_WIDTH),
        randInt(MIN_FIELD_HEIGHT, MAX_FIELD_HEIGHT), diff, player.getLevel(),
        this.currentMapID, randBool());
    player.setPos(map.getStart());
  }

  /**
   * method to advance to the next map.
   */
  public void advanceToNextMap(){
    this.currentMapID += 1;
    this.map = MapCreator.createNewMap(randInt(MIN_FIELD_WIDTH, MAX_FIELD_WIDTH),
        randInt(MIN_FIELD_HEIGHT, MAX_FIELD_HEIGHT), this.difficulty, player.getLevel(),
        this.currentMapID, randBool());
    player.setPos(map.getStart());
  }

  /**
   * method to create the current output prompt for the user.
   * if the player is on a field that contains an enemy, the boolean inFight is set to true
   * and the prompt will be generated by the createFightPrompt method.
   * @return the String prompt that can be used to get the next user input.
   */
  public String createCurrentPrompt(){
    if(inFight){
      return createFightPrompt();
    } else if(current().hasEnemy()){
      inFight = true;
      return createFightPrompt();
    } else {
      String prompt = "You are standing on a";
      if(current().vocal){
        prompt += "n ";
      } else {
        prompt += " ";
      }
      prompt += current().getName();
      prompt += ". What do you want to do?\nType \"help\" or \"h\" to get to the help screen.";
      return prompt;
    }
  }

  /**
   * method to create the fight prompt.
   * will be used to get the user input during fights.
   * @return String fight prompt.
   */
  private String createFightPrompt() {
    Enemy enemy = current().getEnemy();
    String prompt;
    if(enemy.isBoss()){
      prompt = "You stand on a";
      if(current().vocal){
        prompt += "n ";
      } else {
        prompt += " ";
      }
      prompt += " in front of the almighty dragon " + enemy.getName() + "!\n";
      prompt += enemy.getName() + " has " + enemy.getHealth() + " ";
      prompt += " health points left.\nWhat do you want to do?\n";
      prompt += "1: Fight the enemy with your " + player.getWeapon().getName() + "\n";
      prompt += "2: Try to escape the enemy\n";
      prompt += "3: Use item from bag";
      return prompt;
    } else {
      prompt = "You are facing a";
      if(current().vocal){
        prompt += "n ";
      } else {
        prompt += " ";
      }
      prompt += enemy.getName() + ".\nThe enemy carries ";
      if(enemy.getWeapon().vocal){
        prompt += "n ";
      } else {
        prompt += " ";
      }
      prompt += enemy.getWeapon().getName() + " and has " + enemy.getHealth();
      prompt += " health points left.\nWhat do you want to do?\n";
      prompt += "1: Fight the enemy with your " + player.getWeapon().getName() + "\n";
      prompt += "2: Try to escape the enemy\n";
      prompt += "3: Use item from bag";
      return prompt;
    }

  }

  /**
   * method to get quick access to the current field.
   * @return the current Field.
   */
  private Field current(){
    return this.map.getField(this.player.getPos());
  }

  /**
   * method to create a random integer within given bounds.
   * the bounds are inclusive, so the random number can be the bound itself.
   * this method is the preferred standard after java 1.7.
   * @param min int minimum value.
   * @param max int maximum value.
   * @return the randomly generated int.
   */
  private static int randInt(int min, int max){
      return ThreadLocalRandom.current().nextInt(min, max + 1);
  }

  /**
   * method to use as a shortcut to create a new random boolean.
   * uses ThreadLocalRandom to create the new boolean.
   * @return the randomly created boolean.
   */
  private static boolean randBool(){
    return ThreadLocalRandom.current().nextBoolean();
  }

  // Getter and setter methods.
  public Character getPlayer() {
    return player;
  }
  public Map getMap() {
    return map;
  }
  public int getCurrentMapID() {
    return currentMapID;
  }
  public boolean isGameWon() {
    return gameWon;
  }
  public boolean isInFight() {
    return inFight;
  }
  public void setPlayer(Character player) {
    this.player = player;
  }
  public void setMap(Map map) {
    this.map = map;
  }
  public void setCurrentMapID(int currentMapID) {
    this.currentMapID = currentMapID;
  }
  public void setGameWon(boolean gameWon) {
    this.gameWon = gameWon;
  }
  public void setInFight(boolean inFight) {
    this.inFight = inFight;
  }
}
